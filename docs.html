<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Qlibs documentation page</title>
    <style>
      body {
        background-color: black;
      }
      h1 {
        color: #aaaaff;
      }
      h2 {
        color: #aaaaff;
      }
      h3 {
        color: #aaaaff;
      }
      h4 {
        color: #9a9aff;
      }
      p {
        color: #cacaca;
      }
      b {
        color: #5affaa;
      }
      blockquote {
        background: black;
        padding: 0em 0.1em;
      }
    </style>
  </head>
  <body>
    <h1> QLibs documentation </h1>
    <blockquote>
    <h2>Module qlibs.fileworks.__init__</h2>
      <blockquote>
      </blockquote>
      <h2>Module qlibs.fonts.font_render</h2>
      <blockquote>
      <h3>Class DirectFontRender(ctx, font, font_path=None)</h3>
      <blockquote>
      <h4>Function __init__(self, ctx, font, font_path=None)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function render_string(self, text, x, y, scale=1, color=(1, 1, 1), mvp=Matrix4([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]))</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class Glyph(ctx, glyph)</h3>
      <blockquote>
      <h4>Function __init__(self, ctx, glyph)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.fonts.font_search</h2>
      <blockquote>
      <h4>Function find_reasonable_font()</h4>
      <blockquote>
      <p>Try to return system font path, or some other font</p>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.gui.__init__</h2>
      <blockquote>
      </blockquote>
      <h2>Module qlibs.gui.basic_shapes</h2>
      <blockquote>
      <h3>Class ShapeDrawer(ctx, prog=None)</h3>
      <blockquote>
      <h4>Function __init__(self, ctx, prog=None)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function add_polygon(self, points, color=(1, 1, 1))</h4>
      <blockquote>
      </blockquote>
      <h4>Function add_rectangle(self, x, y, w, h, color=(1, 1, 1))</h4>
      <blockquote>
      </blockquote>
      <h4>Function add_triangle(self, points, color=(1, 1, 1))</h4>
      <blockquote>
      </blockquote>
      <h4>Function prepare(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function render(self, mvp=Matrix4([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]))</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.math.matrix</h2>
      <blockquote>
      <p>Matrix module</p>
      <h3>Class Matrix4(data=None, dtype=&#x27;f&#x27;, raw_init=None)</h3>
      <blockquote>
      <h4>Function __init__(self, data=None, dtype=&#x27;f&#x27;, raw_init=None)</h4>
      <blockquote>
      <p>Initialize matrix with 16 elements array (<b>data</b>) of <b>dtype</b> type</p>
      </blockquote>
      <h4>Function bytes(self, dtype=&#x27;f&#x27;)</h4>
      <blockquote>
      <p>Converts internal array to bytes</p>
      </blockquote>
      <h4>Function look_at(eye: qlibs.math.vec.MVec, center: qlibs.math.vec.MVec, up: qlibs.math.vec.MVec)</h4>
      <blockquote>
      <p>Generates a look at matrix from <b>eye</b> to <b>center</b> with <b>up</b> up vector</p>
      </blockquote>
      <h4>Function orthogonal_projection(l, r, b, t, n=-0.1, f=100)</h4>
      <blockquote>
      </blockquote>
      <h4>Function perspective_projection(fov, ratio, near, far)</h4>
      <blockquote>
      <p>Creates perspective projection matrix from <b>fov</b>, <b>ratio</b>(width/height) and         culling planes(<b>near</b> and <b>far</b>)</p>
      </blockquote>
      <h4>Function perspective_projection_lrbtnf(left, right, bottom, top, near, far)</h4>
      <blockquote>
      <p>Creates perspective projection from boundaries</p>
      </blockquote>
      <h4>Function rotation_euler(pitch, roll, yaw)</h4>
      <blockquote>
      <p>Creates rotation matrix from 3 angles(<b>pith</b>, <b>roll</b> and <b>yaw</b>)</p>
      </blockquote>
      <h4>Function scale_matrix(by)</h4>
      <blockquote>
      </blockquote>
      <h4>Function translation_matrix(x, y, z)</h4>
      <blockquote>
      <p>Creates matrix that translates vectors by <b>x</b>, <b>y</b>, <b>z</b></p>
      </blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.math.vec</h2>
      <blockquote>
      <h3>Class IVec(*args)</h3>
      <blockquote>
      <p>Immutable vector type</p>
      <h4>Function __init__(self, *args)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function as_n_d(self, n)</h4>
      <blockquote>
      </blockquote>
      <h4>Function bytes(self, dtype=&#x27;f&#x27;)</h4>
      <blockquote>
      </blockquote>
      <h4>Function cross(self, other)</h4>
      <blockquote>
      </blockquote>
      <h4>Function dot(self, other)</h4>
      <blockquote>
      </blockquote>
      <h4>Function len(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function len_sqr(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function map_by_verticle(self, other, function: &lt;built-in function callable&gt;)</h4>
      <blockquote>
      </blockquote>
      <h4>Function normalized(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function to_tuple(self)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class MVec(*args)</h3>
      <blockquote>
      <p>Mutable vector type</p>
      <h4>Function __init__(self, *args)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function normalize(self)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.models.modelloader</h2>
      <blockquote>
      <p>Module for loading 3D models</p>
      <h3>Class MTLLoader()</h3>
      <blockquote>
      <p>.mtl file loader</p>
      <h4>Function __init__(self)</h4>
      <blockquote>
      <p>Initialize MTLLoader</p>
      </blockquote>
      <h4>Function get_mat(self, name=None)</h4>
      <blockquote>
      <p>Get material with specified <b>name</b>, or latest if <b>name</b> is None</p>
      </blockquote>
      <h4>Function load_file(self, f)</h4>
      <blockquote>
      <p>Load data from file <b>f</b> (<b>f</b> needs to support iteration over lines)</p>
      </blockquote>
      <h4>Function load_path(self, path)</h4>
      <blockquote>
      <p>Calls load_file creating file object from path</p>
      </blockquote>
      </blockquote>
      <h3>Class Material(name)</h3>
      <blockquote>
      <p>Object that describes material properties</p>
      <h4>Function __init__(self, name)</h4>
      <blockquote>
      <p>Make new matereal</p>
      </blockquote>
      <h4>Function process(self, ensure_processing=False)</h4>
      <blockquote>
      <p>Process raw parameters</p>
      <p>Does not process already processed Material          unless <b>ensure_processing</b> specified</p>
      </blockquote>
      </blockquote>
      <h3>Class OBJ(name, materials)</h3>
      <blockquote>
      <p>Loaded object class</p>
      <h4>Function __init__(self, name, materials)</h4>
      <blockquote>
      <p>Initialize new 3d object with given <b>name</b> and <b>materials</b> dict</p>
      </blockquote>
      <h4>Function get_sub_obj(self, material)</h4>
      <blockquote>
      <p>Get SubOBJ for <b>material</b></p>
      </blockquote>
      <h4>Function iter_materials_non_textured(self, *form)</h4>
      <blockquote>
      <p>Iterate over non textured material faces</p>
      </blockquote>
      <h4>Function iter_materials_textured(self, *form)</h4>
      <blockquote>
      <p>Iterate over textured material faces</p>
      </blockquote>
      <h4>Function resolve(self, *form, filter_by=&lt;function OBJ.&lt;lambda&gt; at 0x7f97480b29d8&gt;, material=None)</h4>
      <blockquote>
      <p>Resolves faces to parameter array defined by <b>form</b> format</p>
      </blockquote>
      </blockquote>
      <h3>Class OBJIndex(value, names=None, *, module=None, qualname=None, type=None, start=1)</h3>
      <blockquote>
      <p>Parameters to specify data order</p>
      </blockquote>
      <h3>Class OBJLoader()</h3>
      <blockquote>
      <p>Loads object files</p>
      <h4>Function __init__(self)</h4>
      <blockquote>
      <p>Create new object loader</p>
      </blockquote>
      <h4>Function get_obj(self, name=None)</h4>
      <blockquote>
      <p>Get object by <b>name</b> or latest object if <b>name</b> is None</p>
      </blockquote>
      <h4>Function get_sub_obj(self, name=None, material=None)</h4>
      <blockquote>
      <p>Shortcut for <b>self</b>.get_obj(<b>name</b>).get_sub_obj(<b>material</b>)</p>
      </blockquote>
      <h4>Function load_file(self, f, triangulate=True)</h4>
      <blockquote>
      <p>Loads models from file object</p>
      <p>Triangulates faces if <b>triangulate</b> specified</p>
      </blockquote>
      <h4>Function load_path(self, path)</h4>
      <blockquote>
      <p>Loads models from <b>path</b></p>
      </blockquote>
      </blockquote>
      <h3>Class SubOBJ(name)</h3>
      <blockquote>
      <p>Part of object with one material</p>
      <h4>Function __init__(self, name)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h4>Function check_has_no_textures(face)</h4>
      <blockquote>
      <p>Checks if object&#x27;s face does not have all textures</p>
      </blockquote>
      <h4>Function check_has_textures(face)</h4>
      <blockquote>
      <p>Checks if object&#x27;s face has all textures</p>
      </blockquote>
      <h4>Function index_or_none(value)</h4>
      <blockquote>
      <p>Maps OBJ file index to python 0-index scheme</p>
      </blockquote>
      <h4>Function int_or_none(value)</h4>
      <blockquote>
      <p>Returns int or none if int could not be converted</p>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.models.modelrenderer</h2>
      <blockquote>
      <h3>Class MaterialData(material, vbo, vao)</h3>
      <blockquote>
      <h4>Function __init__(self, material, vbo, vao)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h3>Class RenderableModel(model, scene, ctx, program=None)</h3>
      <blockquote>
      <p>Model wrapper which can render models</p>
      <h4>Function __init__(self, model, scene, ctx, program=None)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function prepare(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function render(self, m, v, p, mvp=None)</h4>
      <blockquote>
      </blockquote>
      <h4>Function reset(self)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class Scene()</h3>
      <blockquote>
      <h4>Function __init__(self)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h4>Function make_program(ctx)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.net.__init__</h2>
      <blockquote>
      </blockquote>
      <h2>Module qlibs.net.asyncsocket</h2>
      <blockquote>
      <p>Async socket library</p>
      <h3>Class AsyncSocket(socket)</h3>
      <blockquote>
      <p>Async socket - writing and reading don&#x27;t block</p>
      <p>Most useful when it is the only socket you need, consider using select if you        need more sockets</p>
      <p>TCP version</p>
      <h4>Function __init__(self, socket)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function accept(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function empty(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function recv(self, amount)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send(self, data=None)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class AsyncUDPSocket(socket)</h3>
      <blockquote>
      <p>Async socket - writing and reading don&#x27;t block</p>
      <p>Most useful when it is the only socket you need, consider using select if you        need more sockets</p>
      <p>UDP version</p>
      <h4>Function __init__(self, socket)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function recv(self, amount=8192)</h4>
      <blockquote>
      </blockquote>
      <h4>Function sendto(self, data, adress)</h4>
      <blockquote>
      </blockquote>
      <h4>Function sendto_buff(self, data, adress)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class PacketSocket(socket, processor, *args)</h3>
      <blockquote>
      <h4>Function __init__(self, socket, processor, *args)</h4>
      <blockquote>
      <p><b>processor</b> should be a generator. </p>
      <p>It will recieve new byte when recieving message.</p>
      <p>Use `data = yield` to recieve one byte as int value</p>
      </blockquote>
      <h4>Function empty(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function recv(self, size=8192)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send(self, data)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.net.connection</h2>
      <blockquote>
      <h3>Class AdvRW(socket)</h3>
      <blockquote>
      <h4>Function __init__(self, socket)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function close(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read_num(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send_rep(self, attemps=10)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write(self, data)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write_num(self, data)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class AsyncAdvRW(socket)</h3>
      <blockquote>
      <h4>Function __init__(self, socket)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function close(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function drain(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read_num(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write(self, data)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write_num(self, data)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class AsyncAdvReader(reader)</h3>
      <blockquote>
      <h4>Function __init__(self, reader)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h3>Class AsyncAdvWriter(writer)</h3>
      <blockquote>
      <h4>Function __init__(self, writer)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h3>Class RWConvertable(socket)</h3>
      <blockquote>
      <h4>Function __init__(self, socket)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function close(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function debug_data(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function recv_data(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send_rep(self, attemps=10)</h4>
      <blockquote>
      </blockquote>
      <h4>Function serve(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write(self, data)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h4>Function b_to_num(inp)</h4>
      <blockquote>
      </blockquote>
      <h4>Function num_to_b(inp, size=4)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.net.qpacket</h2>
      <blockquote>
      <h3>Class BinaryAuto(value, names=None, *, module=None, qualname=None, type=None, start=1)</h3>
      <blockquote>
      <p>An enumeration.</p>
      </blockquote>
      <h3>Class ConvertionLookup()</h3>
      <blockquote>
      <h4>Function __init__(self)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function register(self, obj: type, _id)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class Decoder(data=b&#x27;&#x27;, custom_byte_buffer=None)</h3>
      <blockquote>
      <h4>Function __init__(self, data=b&#x27;&#x27;, custom_byte_buffer=None)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function feed(self, data)</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_value(self, ensure_type=None)</h4>
      <blockquote>
      </blockquote>
      <h4>Function has_values(self)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class SECONDARY_INT_PARAMS(value, names=None, *, module=None, qualname=None, type=None, start=1)</h3>
      <blockquote>
      <p>An enumeration.</p>
      </blockquote>
      <h3>Class VALUE_TYPES(value, names=None, *, module=None, qualname=None, type=None, start=1)</h3>
      <blockquote>
      <p>An enumeration.</p>
      </blockquote>
      <h4>Function _(arg)</h4>
      <blockquote>
      </blockquote>
      <h4>Function convert(arg)</h4>
      <blockquote>
      </blockquote>
      <h4>Function decode(data)</h4>
      <blockquote>
      </blockquote>
      <h4>Function make_qlibs_obj_id(shift)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.resources.resource_loader</h2>
      <blockquote>
      <h3>Class ImageData(size, data)</h3>
      <blockquote>
      <h4>Function __init__(self, size, data)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h3>Class Loader()</h3>
      <blockquote>
      <h4>Function handle_prefix(self, path, prefix)</h4>
      <blockquote>
      </blockquote>
      <h4>Function resolve(self, path)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class MergerLoader(loaders, prefix=None)</h3>
      <blockquote>
      <h4>Function __init__(self, loaders, prefix=None)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function resolve(self, path)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class SearchLocationLoader(location, prefix=None)</h3>
      <blockquote>
      <h4>Function __init__(self, location, prefix=None)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function resolve(self, path)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h4>Function get_lib_res_path()</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_res_data(path)</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_res_path(path)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.resources.resource_manager</h2>
      <blockquote>
      <h3>Class PerContextStorage(ctx)</h3>
      <blockquote>
      <p>Storage for context-specific things</p>
      <h4>Function __init__(self, ctx)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function get_program(self, vertex_shader_name, fragment_shader_name, geometry_shader_name=None)</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_texture(self, r_path)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h4>Function get_storage_of_context(ctx)</h4>
      <blockquote>
      </blockquote>
      <h4>Function load_model(name)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
    </blockquote>
  </body>
</html>

