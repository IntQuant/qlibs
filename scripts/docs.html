
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Qlibs documentation page</title>
  </head>
  <body>
    <h1> QLibs documentation </h1>
    <blockquote>
    <h2>Module qlibs.gui.window_provider.window_provider</h2>
      <blockquote>
      <p>Module that provides opengl-enabled windows</p>
      <h3>Class Window(request=330, win_name=b&#x27;qlibs&#x27;, width=800, height=600)</h3>
      <blockquote>
      <p>Basic window class</p>
      <h4>Function __init__(self, request=330, win_name=b&#x27;qlibs&#x27;, width=800, height=600)</h4>
      <blockquote>
      <p>*request* - OpenGL version to use</p>
      <p>*win_name* - name of the window</p>
      <p>*width* - window width</p>
      <p>*height* - window height</p>
      </blockquote>
      <h4>Function get_events(self)</h4>
      <blockquote>
      <p>Iterate over recent events</p>
      </blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.matrix</h2>
      <blockquote>
      <p>Matrix module</p>
      <h3>Class Matrix4(data=None, dtype=&#x27;f&#x27;)</h3>
      <blockquote>
      <p>4 by 4 Matrix class which allows [i, j] indexing</p>
      <h4>Function __init__(self, data=None, dtype=&#x27;f&#x27;)</h4>
      <blockquote>
      <p>Initialize matrix with 16 elements array (*data*) of *dtype* type</p>
      </blockquote>
      <h4>Function bytes(self, dtype=&#x27;f&#x27;)</h4>
      <blockquote>
      <p>Converts internal array to bytes</p>
      </blockquote>
      <h4>Function look_at(eye: qlibs.vec.Vec, center: qlibs.vec.Vec, up: qlibs.vec.Vec)</h4>
      <blockquote>
      <p>Generates a look at matrix from *eye* to *center* with *up* up vector</p>
      </blockquote>
      <h4>Function orthogonal_projection(fov, ratio, n, f)</h4>
      <blockquote>
      <p>Does not work... Most likely</p>
      </blockquote>
      <h4>Function perspective_projection(fov, ratio, near, far)</h4>
      <blockquote>
      <p>Creates perspective projection matrix from *fov*, *ratio*(width/height) and culling planes(*near* and *far*)</p>
      </blockquote>
      <h4>Function perspective_projection_lrbtnf(left, right, bottom, top, near, far)</h4>
      <blockquote>
      <p>Creates perspective projection from boundaries</p>
      </blockquote>
      <h4>Function rotation_euler(pitch, roll, yaw)</h4>
      <blockquote>
      <p>Creates rotation matrix from 3 angles(*pith*, *roll* and *yaw*)</p>
      </blockquote>
      <h4>Function translation_matrix(x, y, z)</h4>
      <blockquote>
      <p>Creates matrix that translates vectors by *x*, *y*, *z*</p>
      </blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.modelloader</h2>
      <blockquote>
      <p>Module for loading 3D models</p>
      <h3>Class MTLLoader()</h3>
      <blockquote>
      <p>.mtl file loader</p>
      <h4>Function __init__(self)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function get_mat(self, name=None)</h4>
      <blockquote>
      </blockquote>
      <h4>Function load_file(self, f)</h4>
      <blockquote>
      </blockquote>
      <h4>Function load_path(self, path)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class Material(name)</h3>
      <blockquote>
      <p>Object that describes material properties</p>
      <h4>Function __init__(self, name)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function process(self, ensure_processing=False)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class OBJ(name, materials)</h3>
      <blockquote>
      <p>Loaded object class</p>
      <h4>Function __init__(self, name, materials)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function get_sub_obj(self, material)</h4>
      <blockquote>
      </blockquote>
      <h4>Function iter_materials_non_textured(self, *form)</h4>
      <blockquote>
      <p>Iterate over non textured mateial faces</p>
      </blockquote>
      <h4>Function iter_materials_textured(self, *form)</h4>
      <blockquote>
      <p>Iterate over textured material faces</p>
      </blockquote>
      <h4>Function resolve(self, *form, filter_by=&lt;function OBJ.&lt;lambda&gt; at 0x031A7738&gt;, material=None)</h4>
      <blockquote>
      <p>Resolves faces to parameter array defined by *form* format</p>
      </blockquote>
      </blockquote>
      <h3>Class OBJIndex(value, names=None, *, module=None, qualname=None, type=None, start=1)</h3>
      <blockquote>
      <p>Parameters to specify data order</p>
      </blockquote>
      <h3>Class OBJLoader()</h3>
      <blockquote>
      <p>Loads object files</p>
      <h4>Function __init__(self)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function get_obj(self, name=None)</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_sub_obj(self, name=None, material=None)</h4>
      <blockquote>
      </blockquote>
      <h4>Function load_file(self, f, triangulate=True)</h4>
      <blockquote>
      <p>Loads models from file object</p>
      </blockquote>
      <h4>Function load_path(self, path)</h4>
      <blockquote>
      <p>Loads models from *path*</p>
      </blockquote>
      </blockquote>
      <h3>Class SubOBJ(name)</h3>
      <blockquote>
      <p>Part of object with one material</p>
      <h4>Function __init__(self, name)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h4>Function check_has_no_textures(face)</h4>
      <blockquote>
      <p>Checks if object&#x27;s face does not have all textures</p>
      </blockquote>
      <h4>Function check_has_textures(face)</h4>
      <blockquote>
      <p>Checks if object&#x27;s face has all textures</p>
      </blockquote>
      <h4>Function index_or_none(value)</h4>
      <blockquote>
      <p>Maps OBJ file index to python 0-index scheme</p>
      </blockquote>
      <h4>Function int_or_none(value)</h4>
      <blockquote>
      <p>Returns int or none if int could not be converted</p>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.net.connection</h2>
      <blockquote>
      <h3>Class AdvRW(socket)</h3>
      <blockquote>
      <h4>Function __init__(self, socket)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function close(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read_num(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send_rep(self, attemps=10)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write(self, data)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write_num(self, data)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class AsyncAdvRW(socket)</h3>
      <blockquote>
      <h4>Function __init__(self, socket)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function close(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function drain(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read_num(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write(self, data)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write_num(self, data)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class AsyncAdvReader(reader)</h3>
      <blockquote>
      <h4>Function __init__(self, reader)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h3>Class AsyncAdvWriter(writer)</h3>
      <blockquote>
      <h4>Function __init__(self, writer)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      </blockquote>
      <h3>Class RWConvertable(socket)</h3>
      <blockquote>
      <h4>Function __init__(self, socket)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function close(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function debug_data(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function recv_data(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function send_rep(self, attemps=10)</h4>
      <blockquote>
      </blockquote>
      <h4>Function serve(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write(self, data)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h4>Function b_to_num(inp)</h4>
      <blockquote>
      </blockquote>
      <h4>Function num_to_b(inp, size=4)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.net.qpacket</h2>
      <blockquote>
      <h3>Class BinaryAuto(value, names=None, *, module=None, qualname=None, type=None, start=1)</h3>
      <blockquote>
      <p>An enumeration.</p>
      </blockquote>
      <h3>Class ByteBuffer(data=None)</h3>
      <blockquote>
      <h4>Function __init__(self, data=None)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function has_values(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function read(self, read_size)</h4>
      <blockquote>
      </blockquote>
      <h4>Function write(self, data)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class ConvertionLookup()</h3>
      <blockquote>
      <h4>Function __init__(self)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function register(self, obj: type, _id)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class Decoder(data=b&#x27;&#x27;, custom_byte_buffer=None)</h3>
      <blockquote>
      <h4>Function __init__(self, data=b&#x27;&#x27;, custom_byte_buffer=None)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function feed(self, data)</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_value(self, ensure_type=None)</h4>
      <blockquote>
      </blockquote>
      <h4>Function has_values(self)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h3>Class SECONDARY_INT_PARAMS(value, names=None, *, module=None, qualname=None, type=None, start=1)</h3>
      <blockquote>
      <p>An enumeration.</p>
      </blockquote>
      <h3>Class VALUE_TYPES(value, names=None, *, module=None, qualname=None, type=None, start=1)</h3>
      <blockquote>
      <p>An enumeration.</p>
      </blockquote>
      <h4>Function _(arg)</h4>
      <blockquote>
      </blockquote>
      <h4>Function convert(arg)</h4>
      <blockquote>
      </blockquote>
      <h4>Function decode(data)</h4>
      <blockquote>
      </blockquote>
      <h4>Function make_qlibs_obj_id(shift)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.resource_loader</h2>
      <blockquote>
      <h4>Function ensure_sdl2_install()</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_lib_res_path()</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_res_data(path)</h4>
      <blockquote>
      </blockquote>
      <h4>Function get_res_path(path)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.util</h2>
      <blockquote>
      <p>Module for different random things</p>
      <h4>Function dict_cache(fun)</h4>
      <blockquote>
      <p>Function decorator that caches output</p>
      </blockquote>
      <h4>Function try_write(prog, at, data)</h4>
      <blockquote>
      <p>Tries to write data into member of moderngl program</p>
      </blockquote>
      <h4>Function weak_ref_cache(fun)</h4>
      <blockquote>
      <p>Function decorator that caches output using wekrefs</p>
      </blockquote>
      </blockquote>
      <h2>Module qlibs.vec</h2>
      <blockquote>
      <h3>Class Vec(*args)</h3>
      <blockquote>
      <h4>Function __init__(self, *args)</h4>
      <blockquote>
      <p>Initialize self.  See help(type(self)) for accurate signature.</p>
      </blockquote>
      <h4>Function as_n_d(self, n)</h4>
      <blockquote>
      </blockquote>
      <h4>Function bytes(self, dtype=&#x27;f&#x27;)</h4>
      <blockquote>
      </blockquote>
      <h4>Function cross(self, other)</h4>
      <blockquote>
      </blockquote>
      <h4>Function dot(self, other)</h4>
      <blockquote>
      </blockquote>
      <h4>Function intify(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function len(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function len_sqr(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function map_by_verticle(self, other, function: &lt;built-in function callable&gt;)</h4>
      <blockquote>
      </blockquote>
      <h4>Function normalize(self)</h4>
      <blockquote>
      </blockquote>
      <h4>Function to_tuple(self)</h4>
      <blockquote>
      </blockquote>
      </blockquote>
      </blockquote>
    </blockquote>
  </body>
</html>

