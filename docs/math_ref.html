<!DOCTYPE html>
<html>
<head>
     <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <div class="sidenav">
        <p><a href="index.html">[LINK] Back</a></p>
<p><a href="#qlibs.math.vec">qlibs.math.vec</a></p>
<ul class="modulelist"><li><a href=#qlibs.math.vecVecBase>Class VecBase</a></li><li><a href=#qlibs.math.vecVec>Class Vec</a></li><li><a href=#qlibs.math.vecVec2>Class Vec2</a></li></ul>
<p><a href="#qlibs.math.matrix">qlibs.math.matrix</a></p>
<ul class="modulelist"><li><a href=#qlibs.math.matrixMatrix4>Class Matrix4</a></li></ul>
    </div>
    <div class="main">
        <h1 id=qlibs.math.vec>qlibs.math.vec</h1>
<p>None</p>

<h2 id=qlibs.math.vecVecBase>Class VecBase</h2>
<p>None</p>

<div class="classmethods">
<h3 id=qlibs.math.vec__init__> __init__</h3>
<p>Initialize self.  See help(type(self)) for accurate signature.</p>

<h3 id=qlibs.math.vecas_n_d>Function as_n_d(self, n)</h3>
<h3 id=qlibs.math.vecbytes>Function bytes(self, dtype="f")</h3>
<h3 id=qlibs.math.veccross>Function cross(self, other)</h3>
<h3 id=qlibs.math.vecdot>Function dot(self, other)</h3>
<h3 id=qlibs.math.veclen>Function len(self)</h3>
<h3 id=qlibs.math.veclen_sqr>Function len_sqr(self)</h3>
<h3 id=qlibs.math.vecmap_by_verticle>Function map_by_verticle(self, other, function: callable)</h3>
<h3 id=qlibs.math.vecnormalize>Function normalize(self)</h3>
<h3 id=qlibs.math.vecnormalized>Function normalized(self)</h3>
<h3 id=qlibs.math.vecto_tuple>Function to_tuple(self)</h3>
</div>
<h2 id=qlibs.math.vecVec>Class Vec</h2>
<p>None</p>

<div class="classmethods">
<h3 id=qlibs.math.vec__init__>Function __init__(self, *args)</h3>
<p>Initialize self.  See help(type(self)) for accurate signature.</p>

<h3 id=qlibs.math.vecas_n_d>Function as_n_d(self, n)</h3>
<h3 id=qlibs.math.vecbytes>Function bytes(self, dtype="f")</h3>
<h3 id=qlibs.math.veccross>Function cross(self, other)</h3>
<h3 id=qlibs.math.vecdot>Function dot(self, other)</h3>
<h3 id=qlibs.math.veclen>Function len(self)</h3>
<h3 id=qlibs.math.veclen_sqr>Function len_sqr(self)</h3>
<h3 id=qlibs.math.vecmap_by_verticle>Function map_by_verticle(self, other, function: callable)</h3>
<h3 id=qlibs.math.vecnormalize>Function normalize(self)</h3>
<h3 id=qlibs.math.vecnormalized>Function normalized(self)</h3>
<h3 id=qlibs.math.vecto_tuple>Function to_tuple(self)</h3>
</div>
<h2 id=qlibs.math.vecVec2>Class Vec2</h2>
<p>None</p>

<div class="classmethods">
<h3 id=qlibs.math.vec__init__>Function __init__(self, x, y)</h3>
<p>Initialize self.  See help(type(self)) for accurate signature.</p>

<h3 id=qlibs.math.vecas_n_d>Function as_n_d(self, n)</h3>
<h3 id=qlibs.math.vecbytes>Function bytes(self, dtype="f")</h3>
<h3 id=qlibs.math.veccross>Function cross(self, other)</h3>
<h3 id=qlibs.math.vecdot>Function dot(self, other)</h3>
<h3 id=qlibs.math.veclen>Function len(self)</h3>
<h3 id=qlibs.math.veclen_sqr>Function len_sqr(self)</h3>
<h3 id=qlibs.math.vecmap_by_verticle>Function map_by_verticle(self, other, function: callable)</h3>
<h3 id=qlibs.math.vecnormalize>Function normalize(self)</h3>
<h3 id=qlibs.math.vecnormalized>Function normalized(self)</h3>
<h3 id=qlibs.math.vecto_tuple>Function to_tuple(self)</h3>
<h3 id=qlibs.math.vecx>Member x</h3>
<h3 id=qlibs.math.vecy>Member y</h3>
</div>
<h1 id=qlibs.math.matrix>qlibs.math.matrix</h1>
<p>Matrix module</p>

<h2 id=qlibs.math.matrixMatrix4>Class Matrix4</h2>
<p>None</p>

<div class="classmethods">
<h3 id=qlibs.math.matrix__init__>Function __init__(self, data=None, dtype="f", raw_init=None)</h3>
<p>Initialize matrix with 16 elements array (<em>data</em>) of <em>dtype</em> type</p>

<h3 id=qlibs.math.matrixbytes>Function bytes(self, dtype="f")</h3>
<p>Converts internal array to bytes</p>

<h3 id=qlibs.math.matrixlook_at>Method look_at</h3>
<p>Generates a look at matrix from <em>eye</em> to <em>center</em> with <em>up</em> up vector</p>

<h3 id=qlibs.math.matrixorthogonal_projection>Method orthogonal_projection</h3>
<p>Creates orthogonal projection</p>

<h3 id=qlibs.math.matrixperspective_projection>Method perspective_projection</h3>
<p>Creates perspective projection matrix from <em>fov</em>, <em>ratio</em>(width/height) and         culling planes(<em>near</em> and <em>far</em>)</p>

<h3 id=qlibs.math.matrixperspective_projection_lrbtnf>Method perspective_projection_lrbtnf</h3>
<p>Creates perspective projection from boundaries</p>

<h3 id=qlibs.math.matrixrotation_euler>Method rotation_euler</h3>
<p>Creates rotation matrix from 3 angles(<em>pith</em>, <em>roll</em> and <em>yaw</em>)</p>

<h3 id=qlibs.math.matrixscale_matrix>Method scale_matrix</h3>
<p>Creates matrix that scales by <em>by</em></p>

<h3 id=qlibs.math.matrixtranslation_matrix>Method translation_matrix</h3>
<p>Creates matrix that translates vectors by <em>x</em>, <em>y</em>, <em>z</em></p>

</div>
    </div> 
</body>
</html>